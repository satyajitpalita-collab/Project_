const handleDownload = async () => {
    const timestamp = new Date().toISOString().replace(/[:.-]/g, "");
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 15;
    const maxWidth = pageWidth - 2 * margin;
    let y = margin;
    
    const checkPageBreak = (requiredHeight) => {
      if (y + requiredHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
        return true;
      }
      return false;
    };
    
    const addText = (text, fontSize = 10, isBold = false) => {
      doc.setFontSize(fontSize);
      doc.setFont(undefined, isBold ? 'bold' : 'normal');
      
      const lines = doc.splitTextToSize(text, maxWidth);
      const lineHeight = fontSize * 0.5;
      
      lines.forEach((line) => {
        checkPageBreak(lineHeight);
        doc.text(line, margin, y);
        y += lineHeight;
      });
      
      y += 5;
    };
    
    const addSection = (title) => {
      y += 5;
      addText(title, 14, true);
      y += 2;
    };
    
    const addChartToPDF = async (chartElement) => {
      try {
        if (!chartElement) {
          addText("Chart: Unable to locate chart");
          return;
        }
        
        await new Promise(resolve => setTimeout(resolve, 200));
        
        const canvas = await html2canvas(chartElement, {
          backgroundColor: '#ffffff',
          scale: 2,
          logging: false,
          useCORS: true,
          allowTaint: true,
          removeContainer: false
        });
        
        if (!canvas || canvas.width === 0 || canvas.height === 0) {
          addText("Chart: Unable to capture (invalid canvas)");
          return;
        }
        
        const imgData = canvas.toDataURL('image/png');
        
        const aspectRatio = canvas.height / canvas.width;
        let imgWidth = maxWidth;
        let imgHeight = imgWidth * aspectRatio;
        
        const maxImgHeight = pageHeight - 2 * margin - 20;
        if (imgHeight > maxImgHeight) {
          imgHeight = maxImgHeight;
          imgWidth = imgHeight / aspectRatio;
        }
        
        if (imgWidth <= 0 || imgHeight <= 0 || !isFinite(imgWidth) || !isFinite(imgHeight)) {
          addText("Chart: Unable to capture (invalid dimensions)");
          return;
        }
        
        checkPageBreak(imgHeight + 10);
        
        const xPosition = margin + (maxWidth - imgWidth) / 2;
        
        if (xPosition < 0 || y < 0 || !isFinite(xPosition) || !isFinite(y)) {
          addText("Chart: Unable to capture (invalid position)");
          return;
        }
        
        doc.addImage(imgData, 'PNG', xPosition, y, imgWidth, imgHeight);
        y += imgHeight + 10;
        
      } catch (error) {
        console.error('Error capturing chart:', error);
        addText(`Chart: Unable to capture (${error.message})`);
      }
    };
    
    let chartCounter = 0;
    
    for (let i = 0; i < filteredArr?.length; i++) {
      const chat = filteredArr[i];
      const { event, data: chatData } = chat;
      
      const isProgressEvent = [
        "response.status",
        "response.tool_result.status",
        "response.thinking",
        "response.thinking.delta",
        "response.tool_use",
        "response.tool_result"
      ].includes(event);
      
      if (isProgressEvent && !agentProgressToggle) {
        continue;
      }
      
      if (event === "response.thinking") {
        addSection("Thinking Process:");
        addText(chatData?.text);
      }
      else if (event === "response.tool_use") {
        if (agentProgressToggle) {
          addSection("Tool Use:");
          addText(JSON.stringify(chatData, null, 2));
        }
      }
      else if (event === "response.tool_result") {
        if (agentProgressToggle) {
          chatData?.content?.forEach((item) => {
            Object.keys(item?.json).forEach((type) => {
              const data = item?.json[type];
              
              if (type === "sql") {
                addSection("SQL Query:");
                addText(data);
              }
              else if (type === "result_set") {
                const { data: dataT, resultSetMetaData } = data;
                addSection("Data Table:");
                
                const headers = resultSetMetaData?.rowType?.map(item => item?.name);
                if (headers) {
                  addText(headers.join(" | "), 10, true);
                  addText("-".repeat(Math.min(headers.join(" | ").length, 100)));
                  
                  const maxRows = 50;
                  dataT?.slice(0, maxRows).forEach((rowData) => {
                    addText(rowData.join(" | "));
                  });
                  
                  if (dataT?.length > maxRows) {
                    addText(`... and ${dataT.length - maxRows} more rows`);
                  }
                }
              }
            });
          });
        }
      }
      else if (event === "response.chart") {
        addSection("Chart:");
        
        try {
          const spec = chatData?.chart_spec ? JSON.parse(chatData.chart_spec) : null;
          if (spec?.title) {
            addText(spec.title, 12, true);
          }
          
          let chartElement = null;
          
          // Try multiple strategies to find the chart
          const chartElements = Array.from(document.querySelectorAll('[data-chart-id]'));
          if (chartElements[chartCounter]) {
            chartElement = chartElements[chartCounter];
          }
          
          if (!chartElement) {
            const vegaEmbeds = Array.from(document.querySelectorAll('.vega-embed'));
            if (vegaEmbeds[chartCounter]) {
              chartElement = vegaEmbeds[chartCounter];
            }
          }
          
          if (!chartElement) {
            const canvasElements = Array.from(document.querySelectorAll('canvas[class*="marks"]'));
            if (canvasElements[chartCounter]) {
              chartElement = canvasElements[chartCounter].parentElement;
            }
          }
          
          if (chartElement) {
            await addChartToPDF(chartElement);
          } else {
            addText("Chart: Unable to locate chart element");
            console.warn(`Chart ${chartCounter} not found in DOM`);
          }
          
          chartCounter++;
          
        } catch (error) {
          console.error('Error processing chart:', error);
          addText("Chart: Error processing chart data");
        }
      }
      else if (event === "response.table") {
        addSection("Table Data:");
        addText(JSON.stringify(chatData, null, 2));
      }
      else if (event === "response.text") {
        addSection("Response:");
        addText(chatData?.text);
      }
    }
    
    doc.save(`agent_${timestamp}.pdf`);
  };
