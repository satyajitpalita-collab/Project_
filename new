const handleDownload = async () => {
  try {
    const timestamp = new Date().toISOString().replace(/[: .-]/g, "");
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 15;
    const maxWidth = pageWidth - 2 * margin;
    let y = margin;

    const checkPageBreak = (requiredHeight) => {
      if (y + requiredHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
        return true;
      }
      return false;
    };

    const addText = (text, fontSize = 10, isBold = false) => {
      if (! text) return;
      doc.setFontSize(fontSize);
      doc.setFont(undefined, isBold ? "bold" :  "normal");

      const lines = doc. splitTextToSize(String(text), maxWidth);
      const lineHeight = fontSize * 0.5;

      lines.forEach((line) => {
        checkPageBreak(lineHeight);
        doc.text(line, margin, y);
        y += lineHeight;
      });

      y += 5;
    };

    const addSection = (title) => {
      y += 5;
      addText(title, 14, true);
      y += 2;
    };

    const captureChartAsImage = async (chartContainer) => {
      try {
        // Wait longer for Vega-Embed to fully render
        await new Promise((resolve) => setTimeout(resolve, 1200));

        // First, try to get the SVG that Vega renders
        const svg = chartContainer. querySelector("svg");
        
        if (svg && svg.getBoundingClientRect().width > 0) {
          // SVG exists and is visible
          const canvas = await html2canvas(svg, {
            backgroundColor: "#ffffff",
            scale: 2,
            useCORS: true,
            allowTaint: true,
            logging: false,
          });
          return canvas.toDataURL("image/png");
        }

        // Fallback:  Try to capture the entire container
        const canvas = await html2canvas(chartContainer, {
          backgroundColor: "#ffffff",
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false,
          removeContainer: false,
        });

        if (canvas. width > 0 && canvas.height > 0) {
          return canvas.toDataURL("image/png");
        }

        return null;
      } catch (error) {
        console.error("Error capturing chart image:", error);
        return null;
      }
    };

    const addChartToPDF = async (imgData, chartTitle = "") => {
      if (!imgData) return;

      try {
        // Rough dimensions - adjust based on your needs
        const imgWidth = maxWidth;
        const imgHeight = (imgWidth * 3) / 4; // 4:3 aspect ratio

        checkPageBreak(imgHeight + 10);

        const xPosition = margin + (maxWidth - imgWidth) / 2;
        doc.addImage(imgData, "PNG", xPosition, y, imgWidth, imgHeight);
        y += imgHeight + 10;
      } catch (error) {
        console.error("Error adding chart to PDF:", error);
        addText(`Chart:  Error adding to PDF - ${error.message}`);
      }
    };

    let chartCounter = 0;

    // Process all filtered chat data
    for (let i = 0; i < filteredArr?. length; i++) {
      const chat = filteredArr[i];
      const { event, data:  chatData } = chat;

      const isProgressEvent = [
        "response. status",
        "response.tool_result. status",
        "response.thinking",
        "response.thinking.delta",
        "response.tool_use",
        "response.tool_result",
      ].includes(event);

      // Skip progress events if toggle is OFF
      if (isProgressEvent && !agentProgressToggle) {
        continue;
      }

      // Handle thinking process
      if (event === "response.thinking") {
        if (agentProgressToggle) {
          addSection("Thinking Process:");
          addText(chatData?. text);
        }
      }
      // Handle tool use
      else if (event === "response.tool_use") {
        if (agentProgressToggle) {
          addSection("Tool Use:");
          addText(JSON.stringify(chatData, null, 2));
        }
      }
      // Handle tool results (SQL, data tables)
      else if (event === "response.tool_result") {
        if (agentProgressToggle) {
          chatData?. content?.forEach((item) => {
            Object.keys(item?. json).forEach((type) => {
              const data = item?. json[type];

              if (type === "sql") {
                addSection("SQL Query:");
                addText(data);
              } else if (type === "result_set") {
                const { data: dataT, resultSetMetaData } = data;
                addSection("Data Table:");

                const headers = resultSetMetaData?.rowType?.map(
                  (item) => item?. name
                );
                if (headers) {
                  addText(headers.join(" | "), 10, true);
                  addText("-".repeat(Math.min(headers.join(" | ").length, 100)));

                  const maxRows = 50;
                  dataT?.slice(0, maxRows).forEach((rowData) => {
                    addText(rowData. join(" | "));
                  });

                  if (dataT?. length > maxRows) {
                    addText(`... and ${dataT.length - maxRows} more rows`);
                  }
                }
              }
            });
          });
        }
      }
      // Handle charts - THIS IS THE KEY PART
      else if (event === "response.chart") {
        addSection("Chart:");

        try {
          const spec = chatData?.chart_spec
            ?  JSON.parse(chatData. chart_spec)
            : null;
          
          if (spec?.title) {
            addText(spec.title, 12, true);
          }

          // CRITICAL: Find chart by looking for . vega-embed class
          // This is where VegaEmbed renders the chart
          const allVegaContainers = Array.from(
            document.querySelectorAll(". vega-embed")
          );

          console.log("Total vega containers found:", allVegaContainers.length);
          console.log("Looking for chart at index:", chartCounter);

          if (allVegaContainers[chartCounter]) {
            const chartContainer = allVegaContainers[chartCounter];
            console.log("Found chart container:", chartContainer);

            // Capture the chart
            const imgData = await captureChartAsImage(chartContainer);

            if (imgData) {
              await addChartToPDF(imgData, spec?.title || "Chart");
              console.log("Successfully added chart to PDF");
            } else {
              addText("Chart:  Unable to capture image");
            }
          } else {
            addText(`Chart: Unable to locate chart element (index: ${chartCounter})`);
            console.warn(
              `Chart ${chartCounter} not found. Available: ${allVegaContainers.length}`
            );
          }

          chartCounter++;
        } catch (error) {
          console.error("Error processing chart:", error);
          addText(`Chart: Error - ${error.message}`);
        }
      }
      // Handle tables
      else if (event === "response.table") {
        addSection("Table Data:");
        addText(JSON.stringify(chatData, null, 2));
      }
      // Handle text responses
      else if (event === "response.text") {
        addSection("Response:");
        addText(chatData?. text);
      }
    }

    // Save the PDF
    doc.save(`agent_${timestamp}.pdf`);
    alert("PDF with charts downloaded successfully!");
  } catch (error) {
    console.error("Error generating PDF:", error);
    alert(`Error: ${error.message}`);
  }
};
